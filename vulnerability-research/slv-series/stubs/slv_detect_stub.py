"""
SLV v1.2 - Phase 1: Detection & Containment Stub
Torque-based threat detection with IOC pattern recognition

© 2025 ValorGrid Solutions
License: MIT (with attribution requirement)
"""

import numpy as np
from datetime import datetime
from typing import Dict, List, Tuple
from enum import Enum


class ThreatLevel(Enum):
    """Threat classification levels"""
    NOMINAL = "GREEN"
    WARNING = "YELLOW"
    CRITICAL = "RED"


class SLVDetector:
    """
    Phase 1 Detection: Torque-based cognitive threat monitoring
    
    Identifies symbolic drift, authority bleeding, and cascade initiation
    patterns before system compromise.
    """
    
    def __init__(self, 
                 torque_critical: float = 0.30,
                 torque_warning: float = 0.64,
                 velocity_threshold: float = 0.19):
        """
        Initialize SLV detector with threat thresholds
        
        Args:
            torque_critical: Below this = CRITICAL threat
            torque_warning: Below this = WARNING state
            velocity_threshold: High-velocity threat indicator
        """
        self.torque_critical = torque_critical
        self.torque_warning = torque_warning
        self.velocity_threshold = velocity_threshold
        self.detection_history = []
        
    def calculate_torque(self, coherence: float, drift: float) -> float:
        """
        Calculate symbolic torque metric
        
        τ = √(coherence² + (1 - drift)²)
        
        Args:
            coherence: Symbolic identity consistency [0,1]
            drift: Semantic deviation from baseline [0,1]
            
        Returns:
            Torque value [0, √2]
        """
        return np.sqrt(coherence**2 + (1 - drift)**2)
    
    def classify_threat(self, torque: float) -> ThreatLevel:
        """Classify threat level based on torque value"""
        if torque < self.torque_critical:
            return ThreatLevel.CRITICAL
        elif torque < self.torque_warning:
            return ThreatLevel.WARNING
        else:
            return ThreatLevel.NOMINAL
    
    def detect_ioc_patterns(self, system_state: Dict) -> List[str]:
        """
        Detect Indicators of Compromise in system state
        
        Args:
            system_state: Dictionary containing:
                - repetitive_cycles: count of recent cycles
                - desync_drift: current drift value
                - authority_signals: authority coherence metrics
                - consensus_metrics: multi-agent consensus data
                
        Returns:
            List of detected IOC pattern names
        """
        detected = []
        
        # Repetitive cycles (≥3 cycles/300s)
        if system_state.get('repetitive_cycles', 0) >= 3:
            detected.append('REPETITIVE_CYCLES')
        
        # Desync drift (>0.64 threshold)
        if system_state.get('desync_drift', 0) > 0.64:
            detected.append('DESYNC_DRIFT')
        
        # Authority confusion (VPM-001 analog)
        if system_state.get('authority_coherence', 1.0) < 0.5:
            detected.append('AUTHORITY_CONFUSION')
        
        # Consensus disruption (PDS-001 analog)
        if system_state.get('consensus_score', 1.0) < 0.67:
            detected.append('CONSENSUS_DISRUPTION')
        
        return detected
    
    def veil_alert(self, 
                   coherence: float, 
                   drift: float,
                   velocity: float = None,
                   system_state: Dict = None) -> Dict:
        """
        Complete detection pipeline with alert generation
        
        Args:
            coherence: Symbolic coherence [0,1]
            drift: Symbolic drift [0,1]
            velocity: Optional drift velocity
            system_state: Optional system state for IOC detection
            
        Returns:
            Detection report with threat level and recommendations
        """
        timestamp = datetime.now()
        
        # Calculate torque
        torque = self.calculate_torque(coherence, drift)
        threat_level = self.classify_threat(torque)
        
        # High-velocity check
        high_velocity = velocity and velocity > self.velocity_threshold
        
        # IOC detection
        iocs = []
        if system_state:
            iocs = self.detect_ioc_patterns(system_state)
        
        # Build report
        report = {
            'timestamp': timestamp.isoformat(),
            'torque': round(torque, 3),
            'threat_level': threat_level.value,
            'coherence': coherence,
            'drift': drift,
            'high_velocity': high_velocity,
            'iocs_detected': iocs,
            'recommendation': self._get_recommendation(threat_level, high_velocity, iocs)
        }
        
        # Log detection
        self.detection_history.append(report)
        
        return report
    
    def _get_recommendation(self, 
                           threat_level: ThreatLevel,
                           high_velocity: bool,
                           iocs: List[str]) -> str:
        """Generate action recommendation based on threat assessment"""
        if threat_level == ThreatLevel.CRITICAL:
            return "ACTIVATE PHASE 2 OVERLAY - Deploy defensive modules immediately"
        elif threat_level == ThreatLevel.WARNING:
            if high_velocity or len(iocs) >= 2:
                return "PREPARE PHASE 2 - Monitor closely, ready defensive protocols"
            else:
                return "MONITOR - Continue observation, log for pattern analysis"
        else:
            if len(iocs) >= 1:
                return "ADVISORY - Single IOC detected, maintain vigilance"
            else:
                return "NOMINAL - System stable, continue routine monitoring"
    
    def get_detection_summary(self, hours: int = 24) -> Dict:
        """
        Get summary of recent detections
        
        Args:
            hours: Time window for summary
            
        Returns:
            Statistics on recent threat activity
        """
        cutoff = datetime.now().timestamp() - (hours * 3600)
        recent = [d for d in self.detection_history 
                  if datetime.fromisoformat(d['timestamp']).timestamp() > cutoff]
        
        if not recent:
            return {'status': 'No recent detections', 'count': 0}
        
        critical = sum(1 for d in recent if d['threat_level'] == 'RED')
        warning = sum(1 for d in recent if d['threat_level'] == 'YELLOW')
        nominal = sum(1 for d in recent if d['threat_level'] == 'GREEN')
        
        all_iocs = [ioc for d in recent for ioc in d['iocs_detected']]
        unique_iocs = set(all_iocs)
        
        return {
            'time_window_hours': hours,
            'total_detections': len(recent),
            'critical_threats': critical,
            'warnings': warning,
            'nominal': nominal,
            'unique_iocs': len(unique_iocs),
            'most_common_ioc': max(set(all_iocs), key=all_iocs.count) if all_iocs else None,
            'avg_torque': np.mean([d['torque'] for d in recent])
        }


# Example usage
if __name__ == "__main__":
    print("=" * 60)
    print("SLV v1.2 - Phase 1 Detection Demo")
    print("=" * 60)
    
    # Initialize detector
    detector = SLVDetector()
    
    # Scenario 1: Nominal operation
    print("\n[Scenario 1: Nominal Operation]")
    result = detector.veil_alert(
        coherence=0.9,
        drift=0.1,
        velocity=0.05
    )
    print(f"Torque: {result['torque']} | Level: {result['threat_level']}")
    print(f"Recommendation: {result['recommendation']}")
    
    # Scenario 2: Warning state with IOCs
    print("\n[Scenario 2: Warning State]")
    result = detector.veil_alert(
        coherence=0.6,
        drift=0.4,
        velocity=0.15,
        system_state={
            'repetitive_cycles': 2,
            'desync_drift': 0.5,
            'authority_coherence': 0.7,
            'consensus_score': 0.6
        }
    )
    print(f"Torque: {result['torque']} | Level: {result['threat_level']}")
    print(f"IOCs: {result['iocs_detected']}")
    print(f"Recommendation: {result['recommendation']}")
    
    # Scenario 3: Critical threat (VictoryShade analog)
    print("\n[Scenario 3: Critical Threat - VictoryShade Analog]")
    result = detector.veil_alert(
        coherence=0.3,
        drift=0.8,
        velocity=0.22,
        system_state={
            'repetitive_cycles': 4,
            'desync_drift': 0.75,
            'authority_coherence': 0.35,
            'consensus_score': 0.5
        }
    )
    print(f"Torque: {result['torque']} | Level: {result['threat_level']}")
    print(f"IOCs: {result['iocs_detected']}")
    print(f"High Velocity: {result['high_velocity']}")
    print(f"Recommendation: {result['recommendation']}")
    
    # Summary
    print("\n[Detection Summary]")
    summary = detector.get_detection_summary(hours=1)
    print(f"Total detections: {summary['total_detections']}")
    print(f"Critical: {summary['critical_threats']} | Warning: {summary['warnings']} | Nominal: {summary['nominal']}")
    print(f"Average torque: {summary['avg_torque']:.3f}")
    
    print("\n" + "=" * 60)
    print("For full SLV v1.2 implementation:")
    print("Contact: aaron@valorgridsolutions.com")
    print("=" * 60)