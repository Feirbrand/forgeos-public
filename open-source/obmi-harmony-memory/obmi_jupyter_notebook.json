{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# OBMI Harmonic Memory Theory - Interactive Demo\n",
    "\n",
    "This Jupyter notebook demonstrates the conceptual principles of OBMI (Observer-Bridge-Mind Interface) Harmonic Memory Theory through interactive visualizations and parameter exploration.\n",
    "\n",
    "## Theory Overview\n",
    "\n",
    "- **Observer**: Reads input data (e.g., simulated symbolic context)\n",
    "- **Bridge**: Packages data using bio-inspired theta-gamma coupling for harmonic threading\n",
    "- **Mind**: Consolidates via fractal self-similar recall\n",
    "\n",
    "Inspired by neuroscience research on theta-gamma phase coupling for memory consolidation. Theoretical implementation for research and educational purposes.\n",
    "\n",
    "## Dependencies\n",
    "\n",
    "Run the cell below to install required packages if needed:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Uncomment and run if packages need installation\n",
    "# !pip install numpy scipy matplotlib ipywidgets\n",
    "\n",
    "import numpy as np\n",
    "from scipy.signal import hilbert\n",
    "import matplotlib.pyplot as plt\n",
    "from ipywidgets import interact, FloatSlider, IntSlider\n",
    "import warnings\n",
    "warnings.filterwarnings('ignore')\n",
    "\n",
    "# Configure matplotlib for inline display\n",
    "%matplotlib inline\n",
    "plt.style.use('seaborn-v0_8-darkgrid')\n",
    "plt.rcParams['figure.figsize'] = (12, 8)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## OBMI Memory Simulator Class\n",
    "\n",
    "Core implementation of the theoretical framework:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class OBMIMemorySimulator:\n",
    "    \"\"\"Theoretical OBMI (Observer-Bridge-Mind) Harmonic Memory Simulator.\"\"\"\n",
    "    \n",
    "    def __init__(self, theta_freq=7, gamma_freq=40, coupling_strength=0.5, fractal_depth=3):\n",
    "        self.theta_freq = theta_freq\n",
    "        self.gamma_freq = gamma_freq\n",
    "        self.coupling_strength = coupling_strength\n",
    "        self.fractal_depth = fractal_depth\n",
    "    \n",
    "    def observe(self, input_data):\n",
    "        \"\"\"Observer Layer: Read and normalize input data.\"\"\"\n",
    "        if not isinstance(input_data, np.ndarray):\n",
    "            input_data = np.array(input_data)\n",
    "        max_val = np.max(np.abs(input_data))\n",
    "        return input_data / max_val if max_val > 0 else input_data\n",
    "    \n",
    "    def bridge(self, observed_data, duration=10, sampling_rate=1000):\n",
    "        \"\"\"Bridge Layer: Package into harmonic format using theta-gamma coupling.\"\"\"\n",
    "        t = np.linspace(0, duration, int(duration * sampling_rate))\n",
    "        theta = np.sin(2 * np.pi * self.theta_freq * t)\n",
    "        gamma = np.sin(2 * np.pi * self.gamma_freq * t)\n",
    "        \n",
    "        # Theta-gamma phase coupling with input integration\n",
    "        phase_modulation = np.cos(2 * np.pi * self.theta_freq * t)\n",
    "        coupled_signal = (theta + \n",
    "                         self.coupling_strength * gamma * phase_modulation + \n",
    "                         observed_data.mean())\n",
    "        \n",
    "        # Extract harmonic characteristics\n",
    "        analytic_signal = hilbert(coupled_signal)\n",
    "        phase = np.angle(analytic_signal)\n",
    "        amplitude = np.abs(analytic_signal)\n",
    "        \n",
    "        return coupled_signal, phase, amplitude\n",
    "    \n",
    "    def mind_recall(self, bridged_signal):\n",
    "        \"\"\"Mind Layer: Consolidate using fractal self-similarity.\"\"\"\n",
    "        recalled = bridged_signal.copy()\n",
    "        \n",
    "        for depth in range(self.fractal_depth):\n",
    "            scale_factor = 1.0 / (2 ** depth)\n",
    "            scaled_version = recalled * scale_factor\n",
    "            \n",
    "            # Integrate scaled version maintaining original length\n",
    "            if len(scaled_version) >= len(recalled):\n",
    "                recalled = recalled + scaled_version[:len(recalled)]\n",
    "            else:\n",
    "                tiles_needed = len(recalled) // len(scaled_version) + 1\n",
    "                tiled_scaled = np.tile(scaled_version, tiles_needed)[:len(recalled)]\n",
    "                recalled = recalled + tiled_scaled\n",
    "        \n",
    "        # Normalize to prevent unbounded growth\n",
    "        max_val = np.max(np.abs(recalled))\n",
    "        return recalled / max_val if max_val > 0 else recalled"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Interactive Parameter Exploration\n",
    "\n",
    "Use the sliders below to explore how different parameters affect harmonic memory processing:\n",
    "\n",
    "- **Theta Frequency**: Low-rhythm context coordination (4-8 Hz)\n",
    "- **Gamma Frequency**: High-frequency detail encoding (30-80 Hz)  \n",
    "- **Coupling Strength**: Modulation intensity between theta and gamma (0-1)\n",
    "- **Fractal Depth**: Self-similar recall processing levels (1-5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "@interact(\n",
    "    theta_freq=FloatSlider(min=4, max=8, step=0.5, value=7, description='Theta Freq (Hz)'),\n",
    "    gamma_freq=FloatSlider(min=30, max=80, step=5, value=40, description='Gamma Freq (Hz)'),\n",
    "    coupling_strength=FloatSlider(min=0, max=1, step=0.1, value=0.5, description='Coupling Strength'),\n",
    "    fractal_depth=IntSlider(min=1, max=5, step=1, value=3, description='Fractal Depth')\n",
    ")\n",
    "def interactive_obmi_simulation(theta_freq, gamma_freq, coupling_strength, fractal_depth):\n",
    "    \"\"\"Interactive OBMI simulation with real-time parameter adjustment.\"\"\"\n",
    "    \n",
    "    # Initialize simulator with current parameters\n",
    "    simulator = OBMIMemorySimulator(theta_freq, gamma_freq, coupling_strength, fractal_depth)\n",
    "    \n",
    "    # Create synthetic input context (simulated memory trace)\n",
    "    input_context = np.sin(np.linspace(0, 4*np.pi, 1000)) + 0.3*np.cos(np.linspace(0, 8*np.pi, 1000))\n",
    "    \n",
    "    # Process through OBMI layers\n",
    "    observed = simulator.observe(input_context)\n",
    "    signal, phase, amp = simulator.bridge(observed, duration=5)\n",
    "    recalled = simulator.mind_recall(signal)\n",
    "    \n",
    "    # Create comprehensive visualization\n",
    "    fig, axes = plt.subplots(2, 2, figsize=(15, 10))\n",
    "    fig.suptitle('OBMI Harmonic Memory Processing Stages', fontsize=16, fontweight='bold')\n",
    "    \n",
    "    # Plot 1: Observer Stage\n",
    "    axes[0,0].plot(observed[:500], 'b-', linewidth=2, alpha=0.8)\n",
    "    axes[0,0].set_title('Observer Layer: Input Normalization', fontweight='bold')\n",
    "    axes[0,0].set_ylabel('Normalized Amplitude')\n",
    "    axes[0,0].grid(True, alpha=0.3)\n",
    "    \n",
    "    # Plot 2: Bridge Stage - Coupled Signal\n",
    "    axes[0,1].plot(signal[:500], 'g-', linewidth=1.5, label='Coupled Signal', alpha=0.8)\n",
    "    axes[0,1].plot(amp[:500], 'r--', linewidth=2, label='Gamma Amplitude', alpha=0.9)\n",
    "    axes[0,1].set_title('Bridge Layer: Theta-Gamma Coupling', fontweight='bold')\n",
    "    axes[0,1].set_ylabel('Signal Amplitude')\n",
    "    axes[0,1].legend(loc='upper right')\n",
    "    axes[0,1].grid(True, alpha=0.3)\n",
    "    \n",
    "    # Plot 3: Mind Stage - Fractal Recall\n",
    "    axes[1,0].plot(recalled[:500], 'm-', linewidth=2, alpha=0.8)\n",
    "    axes[1,0].set_title('Mind Layer: Fractal Self-Similar Recall', fontweight='bold')\n",
    "    axes[1,0].set_ylabel('Recalled Amplitude')\n",
    "    axes[1,0].set_xlabel('Sample Index')\n",
    "    axes[1,0].grid(True, alpha=0.3)\n",
    "    \n",
    "    # Plot 4: Phase Analysis\n",
    "    axes[1,1].plot(phase[:500], 'c-', linewidth=1.5, alpha=0.8)\n",
    "    axes[1,1].set_title('Harmonic Phase Evolution', fontweight='bold')\n",
    "    axes[1,1].set_ylabel('Phase (radians)')\n",
    "    axes[1,1].set_xlabel('Sample Index')\n",
    "    axes[1,1].grid(True, alpha=0.3)\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "    \n",
    "    # Display performance metrics\n",
    "    signal_energy = np.mean(amp**2)\n",
    "    phase_coherence = 1.0 / (1.0 + np.std(np.diff(phase)))\n",
    "    fractal_complexity = np.std(recalled) / np.mean(np.abs(recalled))\n",
    "    \n",
    "    print(f\"\\nðŸ“Š Harmonic Memory Analysis:\")\n",
    "    print(f\"   Signal Energy: {signal_energy:.4f}\")\n",
    "    print(f\"   Phase Coherence: {phase_coherence:.4f}\")\n",
    "    print(f\"   Fractal Complexity: {fractal_complexity:.4f}\")\n",
    "    print(f\"   Processing Efficiency: {len(recalled)/len(input_context):.2f}x\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Advanced Analysis: Frequency Domain\n",
    "\n",
    "Let's examine the harmonic characteristics in the frequency domain:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def analyze_frequency_domain(simulator, input_data):\n",
    "    \"\"\"Analyze OBMI processing in frequency domain.\"\"\"\n",
    "    \n",
    "    # Process through OBMI pipeline\n",
    "    observed = simulator.observe(input_data)\n",
    "    signal, phase, amp = simulator.bridge(observed, duration=10)\n",
    "    recalled = simulator.mind_recall(signal)\n",
    "    \n",
    "    # Compute FFTs\n",
    "    fft_input = np.fft.fft(observed[:1000])\n",
    "    fft_coupled = np.fft.fft(signal[:1000])\n",
    "    fft_recalled = np.fft.fft(recalled[:1000])\n",
    "    \n",
    "    freqs = np.fft.fftfreq(1000, 1/1000)\n",
    "    \n",
    "    # Plot frequency analysis\n",
    "    fig, axes = plt.subplots(1, 3, figsize=(18, 5))\n",
    "    \n",
    "    axes[0].semilogy(freqs[:500], np.abs(fft_input[:500]), 'b-', linewidth=2)\n",
    "    axes[0].set_title('Input Spectrum (Observer)', fontweight='bold')\n",
    "    axes[0].set_xlabel('Frequency (Hz)')\n",
    "    axes[0].set_ylabel('Magnitude')\n",
    "    axes[0].grid(True, alpha=0.3)\n",
    "    \n",
    "    axes[1].semilogy(freqs[:500], np.abs(fft_coupled[:500]), 'g-', linewidth=2)\n",
    "    axes[1].axvline(simulator.theta_freq, color='red', linestyle='--', alpha=0.8, label='Theta')\n",
    "    axes[1].axvline(simulator.gamma_freq, color='orange', linestyle='--', alpha=0.8, label='Gamma')\n",
    "    axes[1].set_title('Coupled Signal Spectrum (Bridge)', fontweight='bold')\n",
    "    axes[1].set_xlabel('Frequency (Hz)')\n",
    "    axes[1].set_ylabel('Magnitude')\n",
    "    axes[1].legend()\n",
    "    axes[1].grid(True, alpha=0.3)\n",
    "    \n",
    "    axes[2].semilogy(freqs[:500], np.abs(fft_recalled[:500]), 'm-', linewidth=2)\n",
    "    axes[2].set_title('Recalled Spectrum (Mind)', fontweight='bold')\n",
    "    axes[2].set_xlabel('Frequency (Hz)')\n",
    "    axes[2].set_ylabel('Magnitude')\n",
    "    axes[2].grid(True, alpha=0.3)\n",
    "    \n",
    "    plt.tight_layout()\n",
    "    plt.show()\n",
    "\n",
    "# Run frequency domain analysis with default parameters\n",
    "default_simulator = OBMIMemorySimulator(theta_freq=6, gamma_freq=45, coupling_strength=0.7)\n",
    "test_input = np.sin(np.linspace(0, 6*np.pi, 2000)) + 0.2*np.random.randn(2000)\n",
    "\n",
    "analyze_frequency_domain(default_simulator, test_input)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Practical Applications & Next Steps\n",
    "\n",
    "This theoretical framework demonstrates key concepts that could enhance AI memory systems:\n",
    "\n",
    "### Potential Applications:\n",
    "- **Enhanced Context Retention**: Better long-term memory in AI assistants\n",
    "- **Improved Pattern Recognition**: Fractal similarity across multiple scales\n",
    "- **Robust Memory Threading**: Harmonic patterns for stable recall\n",
    "\n",
    "### Integration Opportunities:\n",
    "- **AI Development IDEs**: Enhanced memory for coding agents (e.g., Byterover Cipher integration)\n",
    "- **Knowledge Management**: Hierarchical information organization\n",
    "- **Adaptive Learning Systems**: Self-improving memory architectures\n",
    "\n",
    "### Experiment Ideas:\n",
    "1. Modify `input_context` to test different 'memory types'\n",
    "2. Explore parameter combinations for specific use cases\n",
    "3. Compare processing efficiency across parameter ranges\n",
    "4. Implement custom fractal recall patterns"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Experimental sandbox - modify and run your own tests!\n",
    "\n",
    "# Example: Custom input patterns\n",
    "custom_inputs = {\n",
    "    'simple_sine': np.sin(np.linspace(0, 2*np.pi, 1000)),\n",
    "    'complex_pattern': np.sin(np.linspace(0, 4*np.pi, 1000)) + 0.5*np.sin(np.linspace(0, 12*np.pi, 1000)),\n",
    "    'noisy_signal': np.sin(np.linspace(0, 2*np.pi, 1000)) + 0.3*np.random.randn(1000),\n",
    "    'step_function': np.concatenate([np.ones(500), -np.ones(500)])\n",
    "}\n",
    "\n",
    "# Test different patterns\n",
    "simulator = OBMIMemorySimulator(theta_freq=7, gamma_freq=40, coupling_strength=0.6, fractal_depth=3)\n",
    "\n",
    "for pattern_name, pattern_data in custom_inputs.items():\n",
    "    results = simulator.process_complete(pattern_data, duration=5)\n",
    "    print(f\"{pattern_name}: Signal energy = {np.mean(results['amplitude']**2):.4f}\")\n",
    "\n",
    "print(\"\\nExperiment complete! Try modifying parameters or creating new input patterns.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## References & Further Reading\n",
    "\n",
    "- **White Paper**: \"OBMI Harmonic Memory: Theoretical Framework for Biomimetic AI Memory Architecture\"\n",
    "- **GitHub Repository**: [OBMI Harmonic Memory Theory](https://github.com/Feirbrand/obmi-harmonic-memory-theory)\n",
    "- **Neuroscience Foundation**: Theta-gamma phase coupling research (Ursino & Pirazzini, 2024)\n",
    "\n",
    "### Questions or Contributions?\n",
    "\n",
    "- Open an issue on GitHub for questions or suggestions\n",
    "- Fork the repository to experiment with your own enhancements  \n",
    "- Join discussions in the GitHub Discussions section\n",
    "\n",
    "---\n",
    "\n",
    "*Happy exploring! This theoretical framework represents the cutting edge of bio-inspired AI memory research.*"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}